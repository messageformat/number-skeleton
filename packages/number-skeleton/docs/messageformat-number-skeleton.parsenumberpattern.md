<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [messageformat-number-skeleton](./messageformat-number-skeleton.md) &gt; [parseNumberPattern](./messageformat-number-skeleton.parsenumberpattern.md)

## parseNumberPattern() function

Parse an [ICU NumberFormatter pattern](http://unicode.org/reports/tr35/tr35-numbers.html#Number_Format_Patterns) string into a [Skeleton](./messageformat-number-skeleton.skeleton.md) structure.

<b>Signature:</b>

```typescript
export declare function parseNumberPattern(src: string, currency?: string | null, onError?: (error: NumberFormatError) => void): Skeleton;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  src | <code>string</code> | The pattern string |
|  currency | <code>string &#124; null</code> | If the pattern includes ¤ tokens, their skeleton representation requires a three-letter currency code. |
|  onError | <code>(error: NumberFormatError) =&gt; void</code> | Called when the parser encounters a syntax error. The function will still return a [Skeleton](./messageformat-number-skeleton.skeleton.md)<!-- -->, but it will be incomplete and/or inaccurate. If not defined, the error will be thrown instead. |

<b>Returns:</b>

`Skeleton`

## Remarks

Unlike the skeleton parser, the pattern parser is not able to return partial results on error, and will instead throw. Output padding is not supported.

## Example


```js
import { parseNumberPattern } from 'messageformat-number-skeleton'

parseNumberPattern('#,##0.00 ¤', 'EUR', console.error)
// {
//   group: 'group-auto',
//   precision: {
//     style: 'precision-fraction',
//     minFraction: 2,
//     maxFraction: 2
//   },
//   unit: { style: 'currency', currency: 'EUR' }
// }

```

